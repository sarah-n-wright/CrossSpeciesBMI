import pandas as pd
import numpy as np
import networkx as nx
import ndex2
from getpass import getpass
from updated_netcoloc_functions import get_p_from_permutation_results

from scipy.stats import hypergeom
from statsmodels.stats import contingency_tables

def load_human_seed_genes(filepath, interactome_nodes, trait=''):
    """Takes a gene level p-value file (e.g. generated by PASCAL) and extracts Bonferroni significant genes that exist
    within the chosen biological network

    Args:
        filepath (str): seed gene file to be imported. This file must have 'gene_symbol' and 'pvalue' columns.
        interactome_nodes (list): A list of nodes (gene symbols) in the interactome being used
        trait (str, optional): The trait represented by the seed genes. Defaults to ''.

    Returns:
        list: A list of seed genes meeting a bonferroni corrected pvalue < 0.05
    """
    all_scores = pd.read_csv(filepath, sep="\t", index_col='gene_symbol')
    # subset to genes in the interactome
    if interactome_nodes is not None:
        all_scores = all_scores.loc[list(np.intersect1d(all_scores.index.tolist(), interactome_nodes))]
    # Calculate bonferroni corrected pvalue (alpha=0.05)
    bonf_p = .05/len(all_scores)
    # Get significant genes
    seeds = all_scores[all_scores['pvalue'] < bonf_p].index.tolist()
    print("Number of",trait,"seeds:", len(seeds))
    return seeds


def load_rat_seed_genes(filepath, interactome_nodes, th=1e-4):
    """Takes a gene level p-value file and extracts genes meeting the given p-value threshold that are contained
    within the chosen biological network

    Args:
        filepath (str): seed gene file to be imported. This file must have 'HumanGene' and 'TopSNP P-Value' columns.
        interactome_nodes (list): A list of nodes (gene symbols) in the interactome being used
        th (float, optional): P value threshold to define seed genes. Defaults to 1e-4.

    Returns:
        list: A list of seed genes meeting the p-value threshold
    """
    data = pd.read_csv(filepath, sep="\t")
    data = data.loc[data["TopSNP P-Value"]<= th]
    print("Number of genes meeting p <", th, ":", len(data))
    data = data.dropna(subset=["HumanGene"])
    print("Number of significant genes with human orthologs:", len(data))
    all_seeds = data.HumanGene.unique()           
    seeds = [s for s in all_seeds if s in interactome_nodes]
    print("Final number of seed genes in network:", len(seeds))
    return seeds


def load_pcnet():
    """Loads the PCNet network from NDEx and returns a list of nodes in the network and a networkx graph object of the network

    Returns:
        list: list of nodes in the PCNet Network
        :py:class:`networkx.Graph`: The PCNet network
    """
    interactome_uuid='4de852d9-9908-11e9-bcaf-0ac135e8bacf' # for PCNet
    # interactome_uuid='275bd84e-3d18-11e8-a935-0ac135e8bacf' # for STRING high confidence
    ndex_server='public.ndexbio.org'
    ndex_user=None
    ndex_password=None
    G_int = ndex2.create_nice_cx_from_server(
            ndex_server, 
            username=ndex_user, 
            password=ndex_password, 
            uuid=interactome_uuid
        ).to_networkx()
    nodes = list(G_int.nodes)
    # pcnet appears to have some self edges... should remove them. 
    G_int.remove_edges_from(nx.selfloop_edges(G_int))
    # print out interactome num nodes and edges for diagnostic purposes
    print('number of nodes:')
    print(len(G_int.nodes))
    print('\nnumber of edges:')
    print(len(G_int.edges))
    return nodes, G_int


def load_network(uuid='e8cc9239-d91a-11eb-b666-0ac135e8bacf', use_password=False):
    """Wrapper function for loading a network from NDEx

    Args:
        uuid (str, optional): NDEx identifier. Defaults to 'e8cc9239-d91a-11eb-b666-0ac135e8bacf'.
        use_password (bool, optional): set True if the network is not public. Defaults to False.

    Returns:
        :py:class:`networkx.Graph`: A networkx object of the desired network
    """
    ndex_server='public.ndexbio.org'
    if use_password:
        ndex_user=getpass.getpass("NDEX Username:")
        ndex_password=getpass.getpass("NDEX Password:")
    else:
        ndex_user=None
        ndex_password=None
    G_overlap_cx = ndex2.create_nice_cx_from_server(
            ndex_server, 
            username=ndex_user, 
            password=ndex_password, 
            uuid=uuid)
    G_overlap = G_overlap_cx.to_networkx()
    print('number of nodes:')
    print(len(G_overlap.nodes))
    print('\nnumber of edges:')
    print(len(G_overlap.edges))
    return G_overlap


def get_permutation_stats(obs, perm, trait, ci=0.95):
    """ Calculates the mean observed/expected value as well as upper and lower bounds on the O/E value based on a confidence interval.
    Evaluates the significance of the mean using a Z test.

    Args:
        obs (float): The observed value
        perm (list,:py:class:`numpy.ndarray` ): colleciton of permuted values
        trait (str): the trait represented by `obs` and `perm` to be used to name the results
        ci (float, optional): Confidence interval to be reported. Defaults to 0.95.

    Returns:
        :py:class:`pandas.DataFrame`: The mean o/e, upper bound, lower bound and Z-score pvalue for the trait
    """
    transform = obs / perm
    avg = np.mean(transform)
    upper = np.quantile(transform, ci)
    lower = np.quantile(transform, 1-ci)
    p_value = get_p_from_permutation_results(obs, perm)
    return pd.DataFrame({"Mean":avg, "Upper":upper, "Lower":lower, "p":p_value}, index=[trait])


def get_consensus_z_scores(sampled_results, percentile=.75):
    """returns the consensus z score for each gene across all samples

    Args:
        sampled_results (str, :py:class:`pandas.DataFrame`):  output of netprop_zscore.calculate_heat_zscores_with_sampling. Can be a file path pointing to these results or a dataframe of the results
        percentile (float, optional): Percentile cut off for determining consensus score. Defaults to .75.

    Returns:
        :py:class:`pandas.DataFrame`: Consensus z-scores for all genes based on sampling
    """
    if type(sampled_results) == str:
        results = pd.read_csv(sampled_results, sep="\t", index_col=0)
    else:
        results = sampled_results
    consensus_z = pd.DataFrame({'z': results.quantile(q=percentile, axis=1)})
    return consensus_z


## Utilities for systems map -------------------------------------------------------------
def get_seed_gene_fractions(hier_df, seeds1, seeds2, seed1_name='h_seed', seed2_name='r_seed'):
    """Assess the number of genes in each community that were seed genes from the orginal inputs

    Args:
        hier_df (pd.DataFrame): The hierarchy information of gene communities
        seeds1 (list): List of genes from input 1
        seeds2 (list): List of genes from input 2
        seed1_name (str, optional): Name to give the seed genes from input 1. Defaults to 'h_seed'.
        seed2_name (str, optional): Name to give the seed genes from input 2. Defaults to 'r_seed'.

    Returns:
        pd.DataFrame: The fraction of genes in each community that are seeds in both seeds1 and seeds2, the fraction just in seeds1, the fraction just in seeds2
    """
    hier_df["CD_MemberList"] = hier_df.CD_MemberList.apply(lambda x: x if type(x)==list else x.split(" "))
    comm_genes = hier_df.explode("CD_MemberList")
    comm_genes[seed1_name] = [1 if x in seeds1 else 0 for x in comm_genes.CD_MemberList]
    comm_genes[seed2_name] = [1 if x in seeds2 else 0 for x in comm_genes.CD_MemberList]
    comm_genes["overlap"] = comm_genes.apply(lambda x: x[seed1_name] * x[seed2_name], axis=1)
    a = comm_genes.groupby(level=0).overlap.sum()
    b = comm_genes[comm_genes.overlap != 1].groupby(level=0)[seed1_name].sum()
    c = comm_genes[comm_genes.overlap != 1].groupby(level=0)[seed2_name].sum()
    d = comm_genes.groupby(level=0).CD_MemberList.count()
    counts = pd.concat([a,b,c,d], axis=1)
    counts["network"] = counts.apply(lambda x: x.CD_MemberList - x.overlap - x[seed1_name] - x[seed2_name], axis=1)
    fracs = counts.div(counts.CD_MemberList, axis=0)
    return fracs


## Utilities for MGD Analysis ------------------------------------------------------------

def num_to_mp(number):
    """Converts a number into a mammalian phenotype code. For example 5678 becomes 'MP:0005678'

    Args:
        number (int): numeric suffix of a mammalian phenotype code

    Returns:
        str: The corresponding mammalian phenotype code
    """
    mp = "MP:"
    num = str(number)
    zeros_to_add = 7-len(num)
    mp = [mp] + ["0"] * zeros_to_add + [num]
    return "".join(mp)


def get_MP_description(term, MPO):
    """Extract the description of a mammalian phenotype code from the ontology

    Args:
        term (str): term of interest
        MPO (:py:class:`ddot.Ontology` ): The mammalian phenotype ontology

    Returns:
        str: plain english description of phenotype
    """
    return MPO.node_attr.loc[term].description


def get_mp_graph(datafile="parsed_mp.txt"):
    """ Converts the mammalian phenotype onotology into a networkx graph

    Args:
        datafile (str, optional):  File path to the parsed mammalian phenotype data. Defaults to "parsed_mp.txt".

    Returns:
        :py:class:`networkx.DiGraph`:  A directed graph representing the mammalian phenotype ontology
    """
    mp_data = pd.read_csv(datafile, sep="\t", header=None)
    mp_data.head()
    mp_graph = nx.from_pandas_edgelist(mp_data, 0,1, create_using=nx.DiGraph)
    return mp_graph


def get_top_level_terms(mp_graph, root="MP:0000001" ,exclude=["MP:0003012", "MP:0002873"]):
    """Retrieve all direct descendents of a mammalian phenotype term

    Args:
        mp_graph (:py:class:`networkx.DiGraph`): The graph representing the mammalian phenotype terms
        root (str, optional): The parent term. Defaults to "MP:0000001" - mammalian phenotype.
        exclude (list, optional): Any terms to exlcude. Default exclude 'no phenotypic analysis' and 'normal phenotype'. Defaults to ["MP:0003012", "MP:0002873"].

    Returns:
        list:  All child terms of `root` except those in `exclude`
    """
    return [node for node in nx.dfs_preorder_nodes(mp_graph, root, 1) if node not in exclude][1:]


def change_symbols(mgi_data, pc_node_map):
    """Update the gene symbols in the mgi data to match updated gene symbols in the interaction network

    Args:
        mgi_data (:py:class:`pandas.DataFrame`): dataframe of mgi data
        pc_node_map (:py:class:`pandas.DataFrame`): DataFrame mapping nodes in interaction network to updated symbols

    Returns:
        :py:class:`pandas.DataFrame`: `mgi_data` with 'human_ortholog' column updated
    """
    symbol_map = pd.Series(pc_node_map.index.values, index=pc_node_map["symbol"]).to_dict()
    mgi_data["human_ortholog"] = mgi_data["human_ortholog"].map(symbol_map)
    return mgi_data


def get_gene_hits_no_annotation(genes, term, MPO, term_mapping):
    """Retrieve the subset of genes that are mapped to a given term (or any of it's children in the mammalian phenotype ontology by MGI

    Args:
        genes (list): Set of genes to test for membership
        term (str):  A mammalian phenotype identifier e.g. MP:0005378
        MPO (:py:class:`ddot.Ontology`): Mammalian phenotype ontology with gene mappings from MGI
        term_mapping (dict): Dictionary of all MPO terms and their associated genes.

    Returns:
        set:  Subset of 'genes' that are mapped to 'term' in the MGI
    """
    term_genes = [MPO.genes[idx] for idx in term_mapping[term]]
    overlap = set(genes).intersection(set(term_genes))
    return overlap


## Enrichment Analysis ---------------------------------------------------

def genes_per_node(MPO):
    """Summarizes the gene-term mappings contained in the ontology

    Args:
        MPO (:py:class:`ddot.Ontology`): Mammalian phenotype ontology with gene mappings from MGI

    Returns:
        dict: The number of unique genes associated with a term or any of its children 
        dict: All unique terms to which a gene is mapped
        dict: All unique genes associated with a term or any of its children
    """
    node_order = MPO.topological_sorting(top_down=False)
    nodes = [i for i in node_order]
    results = {i: set(MPO.term_2_gene[i]) for i in node_order}
    genes = {i: set(MPO.gene_2_term[i]) for i in MPO.genes}
    # go through all terms and assign child results to the parent
    while len(nodes) > 0:
        current = nodes.pop()
        children = MPO.parent_2_child[current]
        if len(children) > 0:
            for child in children:
                if child != current:
                    results[current] = results[current].union(results[child])
        for gene in results[current]:
            if gene not in genes.keys():
                genes[gene] = set([current])
            else:
                genes[gene] = genes[gene].union(set([current]))
        else:
            pass
    counts = {k: len(results[k]) for k in results.keys()}
    return counts, genes, results


def community_term_enrichment(community_name, hier_df, MPO, mgi_df, term_counts, gene_to_terms, G_int, keep_genes=None, exclude_genes=None):
    """Takes a community and tests the genes in this community for enrichment of genes associated with phenotypes in MGI

    Args:
        community_name (str): Index of the community to test
        hier_df (:py:class:`pandas.DataFrame`): Dataframe containing the genes in each community as produced by HiDeF
        MPO (:py:class:`ddot.Ontology`): Mammalian phenotype ontology with gene mappings from MGI
        mgi_df (:py:class:`pandas.DataFrame`): Gene phenotype mapping
        term_counts (dict): Number of genes associated with each term, produced by :py:func:`genes_per_node`
        gene_to_terms (dict): Number of terms associated with each gene, produced by :py:func:`genes_per_node`
        G_int (networkx.Graph): The molecular interaction network
        keep_genes (list, optional): List of genes to only include from the analysis. Defaults to None.
        exclude_genes (list, optional): List of genes to exclude from the analysis. Defaults to None.

    Returns:
        :py:class:`pandas.DataFrame`: The enrichment statistics for `community` for all terms in MPO
    """
    # get the genes in the community
    genes = hier_df.loc[community_name, "CD_MemberList"]
    if type(genes) is str:  # split into a list of genes
        genes_all = genes.split(" ")
        N_hier = len(genes_all)
    else:
        genes_all = genes
        N_hier = len(genes_all)
    # only keep genes in the MGI ontology    
    genes = [ g for g in genes_all if g in MPO.genes ]  
    
    # subset genes based on input
    if keep_genes is not None:
        genes = [g for g in genes if g in keep_genes]
        N_hier = len([g for g in genes_all if g in keep_genes])
    if exclude_genes is not None:
        genes = [g for g in genes if g not in exclude_genes]
        N_hier = len([g for g in genes_all if g not in exclude_genes])
    
    # exit if there are no genes remaining
    if len(genes) == 0:
        print("0/"+str(len(genes_all)), "in MPO.genes/seeds")
        return pd.DataFrame()
    
    # Get the terms associated with these genes
    terms = []
    for gene in genes:
        terms += list(gene_to_terms[MPO.genes.index(gene)])

    # Join term totals and observed
    to_test = pd.DataFrame(pd.Series(terms, name="observed").value_counts()).join(pd.Series(term_counts, name="total"))
    M_pool_size = len(G_int.nodes())
    
    # Get odss ratio, p value of odds ratio, and 95% confidence interval
    OR_test = to_test.apply(lambda x: get_contingency_stats(x.observed, x.total, N_hier, M_pool_size), axis=1)
    try: 
        OR_test = pd.concat(list(OR_test), ignore_index=True)
    except TypeError:
        print(OR_test)
        print(N_hier, terms)
    OR_test.index = to_test.index
    to_test = pd.concat([to_test, OR_test], axis=1)
    
    to_test = to_test.assign(hyper_p=lambda z: hypergeom.sf(k=z.observed, M=M_pool_size, n=z.total, N=N_hier))
    desc = MPO.node_attr.loc[to_test.index]
    to_test = to_test.assign(sig_5e6=to_test["hyper_p"] < 5e-6)
    to_test = to_test.join(desc, how="left")
    to_test = to_test.assign(size=N_hier)
    return to_test


def get_contingency_stats(observed, term_size, community_size, network_size):
    """Calculates enrichment statistics for the number of genes associated with a term using a chi-squared test.

    Args:
        observed (int): The number of community genes associated with a term
        term_size (int): The total number of genes associated with a term
        community_size (int): The total number of genes in a community
        network_size (int): The gobal network size

    Returns:
        :py:class:`pandas.DataFrame`: The odds ratio, p value and confidence interval for observed enrichment
    """
    q00 = observed
    q01 = term_size - observed
    q10 = community_size - observed
    q11 = network_size - q00 - q01 - q10
    results_table = [[q00, q01], [q10, q11]]
    #print(results_table)
    CT = contingency_tables.Table2x2(results_table)
    OR_p_temp = CT.oddsratio_pvalue()
    OR_CI_temp = CT.oddsratio_confint()
    OR = CT.oddsratio
    #print(CT.chi2_contribs)
    #return CT
    return pd.DataFrame({"OR":OR, "OR_p": OR_p_temp, "OR_CI_lower":OR_CI_temp[0], "OR_CI_upper":OR_CI_temp[1]}, index=[0])


### Rat eQTLs -------------------------------------------------
def get_rat_eqtls(gtex_data, gene, tissues="all"):
    """Queries the eqtl status of a gene across tissue types

    Args:
        gtex_data (pd.DataFrame): The summary eqtl data from Rat GTEx
        gene (str): A gene name to query for cis-eQTLs
        tissues (str, optional): List of tissues to consider or "all" to consider all available tissues. Defaults to "all".

    Returns:
        pd.DataFrame: The status of the gene across tissues: 1 if there is a significant cis-eQTL, 
            0 if it was tested and is expressed in the tissue but does not have significant cis-eQTL(s), 
            or -1 if it was not tested or not expressed
    """
    if tissues == "all":
        tissues = [x.split("expr_")[1] for x in gtex_data.columns if "expr_" in x]
    if gene not in gtex_data.geneSymbol.values:
        return pd.DataFrame({gene:-1}, index=tissues)
    gene_expr = gtex_data.loc[gtex_data.geneSymbol==gene, ["expr_"+tiss for tiss in tissues]]
    gene_expr.columns = tissues
    gene_tested = gtex_data.loc[gtex_data.geneSymbol==gene, ["tested_"+tiss for tiss in tissues]]
    gene_tested.columns = tissues
    gene_eqtl = gtex_data.loc[gtex_data.geneSymbol==gene, ["eqtl_"+tiss for tiss in tissues]]
    gene_eqtl.columns = tissues
    gene_data = pd.concat([gene_expr, gene_eqtl, gene_tested])
    gene_data.index = ["expr", "eqtl", "tested"]
    gene_data = gene_data.transpose()
    gene_data[gene] = gene_data.apply(lambda x: -1 if (~x.expr or ~x.tested) else 1 if x.expr and x.eqtl else 0, axis=1)
    return gene_data.drop(columns = ["expr", "eqtl", "tested"])


def get_community_eqtls(data, community, gtex_data):
    """Get the eQTL results for all genes in a community

    Args:
        data (pd.DataFrame): Hierarchy information for gene communities
        community (str): Identifier of the community to test
        gtex_data (pd.DataFrame): The summary eQTL data from Rat GTEx.

    Returns:
        pd.DataFrame: Dataframe of genes (columns) and tissues (rows) with entries: 1 - gene has cis-eQTL in tissue, 0- gene does not have cis-eQTL in tissue, 
            -1 - gene was not expressed or not tested in tissue
    """
    genes = data.loc[community, ("CD_MemberList")]
    eq_data = []
    for g in genes:
        g = g[0] + g[1:].lower()
        eq_data.append(get_rat_eqtls(gtex_data, g, "all"))
    return pd.concat(eq_data, axis=1)
